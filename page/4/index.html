<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    

    <!--Author-->
    
        <meta name="author" content="John Doe">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="c-an"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="c-an"/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    
        <meta name="twitter:card" content="summary" />
    
    
    

    <!-- Title -->
    
    <title>page - c-an</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


    <!-- Google Analytics -->
    


<meta name="generator" content="Hexo 6.1.0"></head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about.html">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">c-an</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2022/04/25/%E7%B2%BE%E7%81%B5%E5%8A%A8%E7%94%BB/">
                精灵动画
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2022-04-25</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="添加动画剪辑"><a href="#添加动画剪辑" class="headerlink" title="添加动画剪辑"></a>添加动画剪辑</h1><ul>
<li>Avatar:</li>
</ul>
<p>Unity动画系统Mecanim中的简化骨骼结构和3d素材中实际骨骼间建立的映射，称为Avatar（替身）</p>
<ul>
<li>动画剪辑（Animation clip）</li>
</ul>
<p>动画剪辑（Animation clip）是动画的基本组成部分，包含某些对象应如何随时改变其位置、旋转或其他相关信息。</p>
<p>动画剪辑一般和不同的状态相挂接。比如“静止状态”挂接站立不动的动画、“奔跑状态”挂接奔跑的动画…</p>
<ul>
<li>Animator Controller<br> Animator Controller用来控制不同状态下动画的播放，以及状态间的转换</li>
</ul>
<blockquote>
<p>以上三个部分（Avatar、动画剪辑和Animator Controller）都通过Animator组件一起附加到某个游戏对象上</p>
</blockquote>
<p>下面开始添加动画剪辑</p>
<blockquote>
<p>建立控制器（creat&gt;Animator Controller 记得创建一个Animations的文件夹方便管理），命名为Robot</p>
</blockquote>
<p>以Robot为例</p>
<ul>
<li>添加Animator组件，在Controller中把刚刚创建的Robot挂上去</li>
<li>打开预制件（Prefabs&gt;选中 双击）</li>
<li>Window&gt;Animation&gt;Animation(ctrl+6),要选中预制件，creat，取个名字，存到Animations文件夹下</li>
<li>把素材拖进去<blockquote>
<p>动画样本的默认大小为60，是在Animation窗口内的动画属性上方的Samples设置中设定的<br>时间轴在0：00 - 1：00 之间有60条垂线。因此，动画会以每秒60帧的速度运行，这意味着Unity每秒将精灵渲染60次<br>若是找不到Samples：在Animation窗口的右上角的X号下面的三个圆点，点击，选择Show Samples Rate。为了动画的流畅，请随意修改Samples<br>Unity动画提供反转的功能（Add Property&gt;Sprite Render&gt;Filp X可以对动画素材左右横转，其他类似）<br><br></br></p>
</blockquote>
</li>
</ul>
<h1 id="用混合树管理动画剪辑"><a href="#用混合树管理动画剪辑" class="headerlink" title="用混合树管理动画剪辑"></a>用混合树管理动画剪辑</h1><p>使上面不同的动画剪辑与Robot不同的状态一一对应，这个工作由Animation Controller执行。</p>
<blockquote>
<p>怎样使用Animation Controller？</p>
</blockquote>
<ul>
<li>首先，有两种方法打开。第一种，因为我们已经创建了控制器Robot，只不过还没开始用，点击（Animations&gt;Ruby），open；第二种，Window&gt;Animation&gt;Animator(需选中预制件，才能看到)</li>
<li>对于Animator窗口，在左侧空间，有两个分页，一个是Layers（层次，一般用来管理3D动画，可以用于角色的不同部分），另一个是Parameters（参数与动画脚本进行挂接，用程序来控制参数，参数再通过控制器Animation Controller决定具体播放哪一段动画；一会我们就使用不同的参数来控制动画剪辑的状态的转化）</li>
</ul>
<h2 id="动画状态机"><a href="#动画状态机" class="headerlink" title="动画状态机"></a>动画状态机</h2><ul>
<li>右键点击动画剪辑，Make Transiton，多出来一条线，指向谁，与谁进行连接</li>
</ul>
<h2 id="混合树（这时比动画状态机更简单的方式，用参数来混合多段动画）"><a href="#混合树（这时比动画状态机更简单的方式，用参数来混合多段动画）" class="headerlink" title="混合树（这时比动画状态机更简单的方式，用参数来混合多段动画）"></a>混合树（这时比动画状态机更简单的方式，用参数来混合多段动画）</h2><ul>
<li>回到Animator窗口，把窗口右侧的动画剪辑State上删掉</li>
<li>调出混合树来专门管理动画剪辑的播放。新建一个混合树：右键，Create State（创建状态）&gt;From New Blend Tree</li>
<li>双击进入Blend Tree，接下来的操作都在Blend Tree里进行。然后要用到参数面板，左侧是搜索框，用来搜索不同的参数，右侧+号是下拉列表，用于新建不同数据类型的参数</li>
<li>（右侧是用鼠标中键来移动的：点击鼠标中键，拖拽）</li>
<li>把原来的参数的delete，新建立2个（和教程上保持一致，命名为Move X,Move Y）</li>
<li>选中Blend Tree，右侧Inspector里的Blend Type是选择类型。因为是实例，选择简单的2D Simple Directional，参数Parameters选中Move X和Move Y</li>
<li>这时Blend Tree 已经有Move X 和Move Y了，它的默认值是0到1</li>
<li>Inspector&gt;Motion(添加参数与动画剪辑之间关联的)，点击+号，Add Motion Field，有几个不同的动画剪辑，添加几个</li>
<li>Motion 挂接动画剪辑就行了</li>
<li>对Pos X，Pos Y两个参数的值进行配置，根据它们进行挂接（tip:后面的钟是播放速度，第四个是镜像）<blockquote>
<p>这时，Blend Tree设置好了<br><br></br></p>
</blockquote>
</li>
</ul>
<h2 id="将参数发送到Animator-Controller"><a href="#将参数发送到Animator-Controller" class="headerlink" title="将参数发送到Animator Controller"></a>将参数发送到Animator Controller</h2><blockquote>
<p>脚本里面设置好移动方向，计时器里设置方向的转化，同时也会进行动画剪辑的设定，根据方向控制播放哪一个的动画剪辑</p>
</blockquote>
<ul>
<li>首先获取Animator组件</li>
<li>组件里的Controller就可以对代码进行控制了</li>
<li>实际还是通过Animator这个组件的对象来进行参数的传递的</li>
</ul>
<p>以下是EnemyController2完整的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">public class EnemyController2 : MonoBehaviour &#123;</span><br><span class="line">    //代表移动速度（实际上是每次刷新时移动的距离）</span><br><span class="line">    public float speed;</span><br><span class="line">    //是否垂直移动，true按y轴移动，false按x轴移动</span><br><span class="line">    public bool vertical;</span><br><span class="line"></span><br><span class="line">    //声明刚体对象</span><br><span class="line">    //rigidbody2D先前我们已经用过了，如果不希望rigidbody2D被覆盖</span><br><span class="line">    //这里可以取比如rigidbody2d这种不一样的名字</span><br><span class="line">    Rigidbody2D rigidbody2d;</span><br><span class="line"></span><br><span class="line">    //朝一个方向移动的总时间</span><br><span class="line">    public float changeTime = 3.0f;</span><br><span class="line"></span><br><span class="line">    //计时器</span><br><span class="line">    float timer;</span><br><span class="line">    //方向</span><br><span class="line">    int direction = 1;</span><br><span class="line">    // Start is called before the first frame update</span><br><span class="line"></span><br><span class="line">    //在字段里面声明一个Animator,动画管理者组件</span><br><span class="line">    Animator animator;</span><br><span class="line">    void Start() &#123;</span><br><span class="line">        //通过当前这个代码组件，获取到这个代码组件所在的游戏对象</span><br><span class="line">        //再通过游戏对象，获取到刚体组件</span><br><span class="line">        rigidbody2d = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line"></span><br><span class="line">        //游戏对象一般都是通过Start获取</span><br><span class="line">        rigidbody2d = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        //计时器也要给它设置好</span><br><span class="line">        timer = changeTime;</span><br><span class="line">        //把Animator实例化，拿到脚本组件所挂接的游戏对象的Animator组件</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //Update本来是每帧来调用，但是和FixedUpdate结合使用，它又是固定的</span><br><span class="line">    void Update() &#123;</span><br><span class="line">        //每次减少</span><br><span class="line">        //但是每秒减少还是一样的</span><br><span class="line">        timer -= Time.deltaTime;</span><br><span class="line">        //如果timer到0，重置</span><br><span class="line">        if (timer &lt; 0) &#123;</span><br><span class="line">            //方向取反</span><br><span class="line">            direction = -direction;</span><br><span class="line">            //时间重置</span><br><span class="line">            timer = changeTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //若是希望移动非常稳定的话，用FixedUpdate</span><br><span class="line">    private void FixedUpdate() &#123;</span><br><span class="line">        //获取当前游戏对象所在的位置</span><br><span class="line">        Vector2 position = rigidbody2d.position;</span><br><span class="line"></span><br><span class="line">        //纵向移动，沿y轴移动</span><br><span class="line">        //加不加Time.deltaTime都可以</span><br><span class="line">        if (vertical) &#123;</span><br><span class="line">            position.y = position.y + Time.deltaTime * speed*direction;</span><br><span class="line">            animator.SetFloat(&quot;Move X&quot;, 0);</span><br><span class="line">            animator.SetFloat(&quot;Move Y&quot;, direction);</span><br><span class="line">        &#125;</span><br><span class="line">        //否则，沿x轴移动</span><br><span class="line">        else &#123;</span><br><span class="line">            position.x = position.x + Time.deltaTime * speed*direction;</span><br><span class="line">            animator.SetFloat(&quot;Move X&quot;, direction);</span><br><span class="line">            animator.SetFloat(&quot;Move Y&quot;, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //和直接赋值的效果是一样的，但是这个更严谨些</span><br><span class="line">        rigidbody2d.MovePosition(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //刚体碰撞的方法</span><br><span class="line">    //在这个方法中，添加对玩家伤害的逻辑</span><br><span class="line">    private void OnCollisionEnter2D(Collision2D other) &#123;</span><br><span class="line">        //获取和敌人碰撞的玩家角色</span><br><span class="line">        //先获取玩家控制器脚本</span><br><span class="line">        //这个类的设置不能直接GetComponent</span><br><span class="line">        //要先获得gameObject</span><br><span class="line">        //这个是类设定的规则，记住这个方式来使用</span><br><span class="line">        RubyController rubyController = other.gameObject.GetComponent&lt;RubyController&gt;();</span><br><span class="line"></span><br><span class="line">        //如果不为空，直接让它减血</span><br><span class="line">        if (rubyController != null) &#123;</span><br><span class="line">            //玩家角色掉血</span><br><span class="line">            rubyController.ChangeHealth(-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Enemy Controller2&gt;Change Time 修改速度<br>Hierarchy&gt;Robot&gt;Enemy Controller2 勾选Vertical，纵向</p>
</blockquote>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2022/04/25/%E6%B7%BB%E5%8A%A0%E6%95%8C%E4%BA%BA%E4%BC%A4%E5%AE%B3/">
                添加敌人伤害
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2022-04-25</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <blockquote>
<p>若是要实现敌人对角色的伤害，而并非通过触发器的碰撞（Box Collider 2D&gt;Is Trigger，若是触发器会导致玩家像鬼魂一样穿过敌人)</p>
</blockquote>
<blockquote>
<p>若是要敌人<strong>碰撞体</strong>为实心，并且与角色实际碰撞，使用OnCollisionEnter2D(刚体与某个对象碰撞时调用的函数)，类似于伤害区的OnTriggerEnter2D</p>
</blockquote>
<blockquote>
<p>下面是EnemyController2完整的代码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">public class EnemyController2 : MonoBehaviour &#123;</span><br><span class="line">    //代表移动速度（实际上是每次刷新时移动的距离）</span><br><span class="line">    public float speed;</span><br><span class="line">    //是否垂直移动，true按y轴移动，false按x轴移动</span><br><span class="line">    public bool vertical;</span><br><span class="line"></span><br><span class="line">    //声明刚体对象</span><br><span class="line">    //rigidbody2D先前我们已经用过了，如果不希望rigidbody2D被覆盖</span><br><span class="line">    //这里可以取比如rigidbody2d这种不一样的名字</span><br><span class="line">    Rigidbody2D rigidbody2d;</span><br><span class="line"></span><br><span class="line">    //朝一个方向移动的总时间</span><br><span class="line">    public float changeTime = 3.0f;</span><br><span class="line"></span><br><span class="line">    //计时器</span><br><span class="line">    float timer;</span><br><span class="line">    //方向</span><br><span class="line">    int direction = 1;</span><br><span class="line">    // Start is called before the first frame update</span><br><span class="line">    void Start() &#123;</span><br><span class="line">        //通过当前这个代码组件，获取到这个代码组件所在的游戏对象</span><br><span class="line">        //再通过游戏对象，获取到刚体组件</span><br><span class="line">        rigidbody2d = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //Update本来是每帧来调用，但是和FixedUpdate结合使用，它又是固定的</span><br><span class="line">    void Update() &#123;</span><br><span class="line">        //每次减少</span><br><span class="line">        //但是每秒减少还是一样的</span><br><span class="line">        timer -= Time.deltaTime;</span><br><span class="line">        //如果timer到0，重置</span><br><span class="line">        if (timer &lt; 0) &#123;</span><br><span class="line">            //方向取反</span><br><span class="line">            direction = -direction;</span><br><span class="line">            //时间重置</span><br><span class="line">            timer = changeTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //若是希望移动非常稳定的话，用FixedUpdate</span><br><span class="line">    private void FixedUpdate() &#123;</span><br><span class="line">        //获取当前游戏对象所在的位置</span><br><span class="line">        Vector2 position = rigidbody2d.position;</span><br><span class="line"></span><br><span class="line">        //纵向移动，沿y轴移动</span><br><span class="line">        //加不加Time.deltaTime都可以</span><br><span class="line">        if (vertical) &#123;</span><br><span class="line">            position.y = position.y + Time.deltaTime * speed*direction;</span><br><span class="line">        &#125;</span><br><span class="line">        //否则，沿x轴移动</span><br><span class="line">        else &#123;</span><br><span class="line">            position.x = position.x + Time.deltaTime * speed*direction;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //和直接赋值的效果是一样的，但是这个更严谨些</span><br><span class="line">        rigidbody2d.MovePosition(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //刚体碰撞的方法</span><br><span class="line">    //在这个方法中，添加对玩家伤害的逻辑</span><br><span class="line">    private void OnCollisionEnter2D(Collision2D other) &#123;</span><br><span class="line">        //获取和敌人碰撞的玩家角色</span><br><span class="line">        //先获取玩家控制器脚本</span><br><span class="line">        //这个类的设置不能直接GetComponent</span><br><span class="line">        //要先获得gameObject</span><br><span class="line">        //这个是类设定的规则，记住这个方式来使用</span><br><span class="line">        RubyController rubyController = other.gameObject.GetComponent&lt;RubyController&gt;();</span><br><span class="line"></span><br><span class="line">        //如果不为空，直接让它减血</span><br><span class="line">        if (rubyController != null) &#123;</span><br><span class="line">            //玩家角色掉血</span><br><span class="line">            rubyController.ChangeHealth(-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="关于Collision2D"><a href="#关于Collision2D" class="headerlink" title="关于Collision2D"></a>关于Collision2D</h1><p>该类对象是回调函数返回的碰撞细节。用来描述碰撞本身。<br>是包含碰撞信息的一个类</p>
<p>可以通过碰撞细节事件函数（回调函数）来编写两个刚体碰撞后的游戏逻辑</p>
<h2 id="碰撞回调函数有三个"><a href="#碰撞回调函数有三个" class="headerlink" title="碰撞回调函数有三个"></a>碰撞回调函数有三个</h2><ul>
<li>OnCollisionEnter2D(MonoBehaviour.OnCollisionEnter2D)</li>
<li>OnCollisionStay2D(OnCollisionEnter2D.OnCollisionStay2D)</li>
<li>OnCollisionExit2D(OnCollisionEnter2D.OnCollisionExity2D)</li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2022/04/24/%E6%95%8C%E4%BA%BA%E7%A7%BB%E5%8A%A8%E6%96%B9%E5%BC%8F/">
                敌人移动方式
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2022-04-24</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <blockquote>
<p>来设计一个敌人，并设计敌人的移动方式吧。下面是敌人移动方式的代码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class EnemyController : MonoBehaviour &#123;</span><br><span class="line">    //设定移动变量速度</span><br><span class="line">    public float speed = 0.1f;</span><br><span class="line">    //声明一个2D刚体对象</span><br><span class="line">    Rigidbody2D rigidbody2D;</span><br><span class="line">    //声明Vector2对象来存放敌人当前位置</span><br><span class="line">    Vector2 position;</span><br><span class="line">    //声明一个初始y坐标变量</span><br><span class="line">    float initY;</span><br><span class="line">    //声明一个移动方向的变量</span><br><span class="line">    float direction;</span><br><span class="line">    //存放移动距离的变量，设置为公有，开放在unity中的访问</span><br><span class="line">    public float distance = 4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Start is called before the first frame update</span><br><span class="line">    void Start() &#123; </span><br><span class="line">        //获取这些对象或变量在游戏开始时的值</span><br><span class="line">        rigidbody2D = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        //获取起始位置</span><br><span class="line">        position = transform.position;</span><br><span class="line">        //获取起始位置，最终还是为了获取y坐标</span><br><span class="line">        initY = position.y;</span><br><span class="line">        //设定初始移动方向</span><br><span class="line">        //我们设定direction要么是1.0，要么是-1.0</span><br><span class="line">        //-1.0代表折返</span><br><span class="line">        direction = 1.0f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void FixedUpdate() &#123;</span><br><span class="line">        //通过刚体移动的方法调用，放入fixupdate方法中，0.02秒执行一次</span><br><span class="line">        MovePositon();//这是我们自定义的一个方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //自定义在Y轴折返移动的算法</span><br><span class="line">    private void MovePositon() &#123;</span><br><span class="line">        //每次满足其中的一种或两种条件</span><br><span class="line">        if(position.y-initY&lt;distance&amp;&amp;direction&gt;0)v&#123;</span><br><span class="line">            position.y += speed;</span><br><span class="line">        &#125;</span><br><span class="line">        if (position.y - initY &gt;= distance &amp;&amp; direction &gt; 0) &#123;</span><br><span class="line">            direction = -0.1f;</span><br><span class="line">        &#125;</span><br><span class="line">        if (position.y - initY &gt; 0 &amp;&amp; direction &lt; 0) &#123;</span><br><span class="line">            position.y -= speed;</span><br><span class="line">        &#125;</span><br><span class="line">        if (position.y - initY &lt;= distance &amp;&amp; direction &gt; 0) &#123;</span><br><span class="line">            direction = 0.1f;</span><br><span class="line">        &#125;</span><br><span class="line">        //通过刚体系统移动游戏对象</span><br><span class="line">        rigidbody2D.position = position;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>把上述的移动方式屏蔽（取消脚本勾选），来看另一种方法吧（更完善）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class EnemyController2 : MonoBehaviour &#123;</span><br><span class="line">    //代表移动速度（实际上是每次刷新时移动的距离）</span><br><span class="line">    public float speed;</span><br><span class="line">    //是否垂直移动，true按y轴移动，false按x轴移动</span><br><span class="line">    public bool vertical;</span><br><span class="line"></span><br><span class="line">    //声明刚体对象</span><br><span class="line">    //rigidbody2D先前我们已经用过了，如果不希望rigidbody2D被覆盖</span><br><span class="line">    //这里可以取比如rigidbody2d这种不一样的名字</span><br><span class="line">    Rigidbody2D rigidbody2d;</span><br><span class="line"></span><br><span class="line">    //朝一个方向移动的总时间</span><br><span class="line">    public float changeTime = 3.0f;</span><br><span class="line"></span><br><span class="line">    //计时器</span><br><span class="line">    float timer;</span><br><span class="line">    //方向</span><br><span class="line">    int direction = 1;</span><br><span class="line">    // Start is called before the first frame update</span><br><span class="line">    void Start() &#123;</span><br><span class="line">        //通过当前这个代码组件，获取到这个代码组件所在的游戏对象</span><br><span class="line">        //再通过游戏对象，获取到刚体组件</span><br><span class="line">        rigidbody2d = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //Update本来是每帧来调用，但是和FixedUpdate结合使用，它又是固定的</span><br><span class="line">    void Update() &#123;</span><br><span class="line">        //每次减少</span><br><span class="line">        //但是每秒减少还是一样的</span><br><span class="line">        timer -= Time.deltaTime;</span><br><span class="line">        //如果timer到0，重置</span><br><span class="line">        if (timer &lt; 0) &#123;</span><br><span class="line">            //方向取反</span><br><span class="line">            direction = -direction;</span><br><span class="line">            //时间重置</span><br><span class="line">            timer = changeTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //若是希望移动非常稳定的话，用FixedUpdate</span><br><span class="line">    private void FixedUpdate() &#123;</span><br><span class="line">        //获取当前游戏对象所在的位置</span><br><span class="line">        Vector2 position = rigidbody2d.position;</span><br><span class="line"></span><br><span class="line">        //纵向移动，沿y轴移动</span><br><span class="line">        //加不加Time.deltaTime都可以</span><br><span class="line">        if (vertical) &#123;</span><br><span class="line">            position.y = position.y + Time.deltaTime * speed*direction;</span><br><span class="line">        &#125;</span><br><span class="line">        //否则，沿x轴移动</span><br><span class="line">        else &#123;</span><br><span class="line">            position.x = position.x + Time.deltaTime * speed*direction;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //和直接赋值的效果是一样的，但是这个更严谨些</span><br><span class="line">        rigidbody2d.MovePosition(position);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2022/04/23/%E5%B9%B3%E9%93%BA%E6%8E%89%E8%A1%80%E5%8C%BA%E5%9F%9F/">
                平铺掉血区域
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2022-04-23</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p>假设我们已做好了关于掉血区域的预制件，要做一片连续的掉血区域。把预制件一个一个进行拼接，就显得有点呆。</p>
<blockquote>
<p>Unity自带平铺的功能<br>下面我们来看看如何进行使用</p>
</blockquote>
<p>Damageable是我已做好的掉血区域的预制件。</p>
<p>让我们对它的属性进行一个更改</p>
<ul>
<li>1.首先，先把游戏对象的缩放进行取消。把Transform中的Scale中的x，y，z都设置为1</li>
<li>2.Sprite Renderer&gt;Draw Mode(可选Simple，Slice,Tiled)，把原来的Simple改成Tiled（平铺）</li>
<li>3.在操作2后，我们能看到出现了一个警告“Sprite Tilling might not appear correctly because the Sprite used is not generated with Full Rect or Sprite Mode is set to Polygon mode.To fix this,change the Mesh Type in the Sprite’s import setting to Full Rect and Sprite Mode is either Single or Multiple。”</li>
<li>4.打开对应的素材，单击它。在Sprite Mode中的Mesh Type，把Tight改成Full Rect</li>
<li>5.设置往之后，apply（应用&#x2F;保存）</li>
<li>6.这时回到Scence，再拉去选框（矩形工具），就是平铺的效果了。当然，在Scale也能进行缩放</li>
<li>7.但是要注意，在设置完平铺的效果后，碰撞区域依然的原来的大小，这是不对的。在Box Collider 2D（碰撞体）里面，勾选Auto Tiling（自动平铺）</li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2022/04/23/%E8%AE%BE%E7%BD%AE%E6%97%A0%E6%95%8C%E6%97%B6%E9%97%B4/">
                设置无敌时间
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2022-04-23</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <blockquote>
<p>对角色设置无敌时间</p>
</blockquote>
<ul>
<li>Part 1<br>设置无敌时间和无敌变量</li>
<li>Part 2<br>判断是否处于无敌状态</li>
<li>Part 3<br>对于是否处于无敌状态相对应的操作</li>
</ul>
<p><br></br></p>
<p>下面是完整的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">public class RubyController : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    //设置玩家间隔无敌时间</span><br><span class="line">    public float timeInvincible = 2.0f;</span><br><span class="line">    //设置是否无敌的变量</span><br><span class="line">    bool isInvincible;</span><br><span class="line">    //定义变量，进行无敌时间的计时，无敌时间计时器</span><br><span class="line">    float invincibleTimer;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    //设置最大生命值（生命上限）</span><br><span class="line">    public int maxHealth = 5;</span><br><span class="line">    //设置当前生命值的属性health</span><br><span class="line"></span><br><span class="line">    //c#中支持面向对象程序设计中的封装概念，对数据成员的保护</span><br><span class="line">    //数据成员变量，默认一般都应该设置为私有，只能通过对当前类的方法或属性进行访问</span><br><span class="line">    //属性类似于特殊的函数结构，它get是一个关键字</span><br><span class="line">    //get是获取当前属性所绑定的字段的值</span><br><span class="line">    //属性相当于一个盒子，字段是在盒子里的某件东西</span><br><span class="line">    //属性限制了字段的访问规则，比如只能读或写</span><br><span class="line">    //或者读写的时候满足某种需求，才能往外进行操作</span><br><span class="line">    //相当于把它包装起来，这就称为封装</span><br><span class="line">    //属性是公有的，可以通过取值器get、赋值器set设定对应字段的访问规则，满足规则才能进行访问</span><br><span class="line"></span><br><span class="line">    public int health &#123; </span><br><span class="line">        get &#123; return currentHealth; &#125;</span><br><span class="line">        //set &#123; currentHealth = value; &#125;//可赋值</span><br><span class="line">    &#125;</span><br><span class="line">    int currentHealth;</span><br><span class="line"></span><br><span class="line">    //声明刚体对象</span><br><span class="line">    Rigidbody2D rigidbody2D;</span><br><span class="line">    //获取用户输入</span><br><span class="line">    float horizontal;</span><br><span class="line">    float vertical;</span><br><span class="line"></span><br><span class="line">    //将速度暴露出来，使其可调</span><br><span class="line">    public float speed = 0.1f;</span><br><span class="line"></span><br><span class="line">    private void Start() &#123;</span><br><span class="line">        //获取当前游戏对象的刚体组件</span><br><span class="line">        rigidbody2D = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        //游戏刚开始，玩家满血</span><br><span class="line">        currentHealth = maxHealth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Update is called once per frame</span><br><span class="line">    //每帧调用一次Update</span><br><span class="line">    //让游戏对象每帧右移0.1</span><br><span class="line">    void Update() &#123;</span><br><span class="line">        //获取水平输入，按向左，会获得-1.0f；按向右，会获得1.0f</span><br><span class="line">        horizontal = Input.GetAxis(&quot;Horizontal&quot;);</span><br><span class="line">        //获取垂直输入，按向下，会获得-1.0f；按向上，会获得1.0f</span><br><span class="line">        vertical = Input.GetAxis(&quot;Vertical&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //判断是否处于无敌状态，来进行计时器的倒计时</span><br><span class="line">        if (isInvincible) &#123;</span><br><span class="line">            //每次Update减去一帧消耗的时间</span><br><span class="line">            invincibleTimer = invincibleTimer - Time.deltaTime;</span><br><span class="line">            if (invincibleTimer &lt; 0) &#123;</span><br><span class="line">                isInvincible = false;//无敌时间小于0了，让它不无敌了</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //固定时间间隔执行的更新方法</span><br><span class="line">    private void FixedUpdate() &#123;</span><br><span class="line">        //获取当前对象位置</span><br><span class="line">        Vector2 position = transform.position;</span><br><span class="line">        //更改位置</span><br><span class="line">        position.x = position.x + 0.1f * horizontal;</span><br><span class="line">        position.y = position.y + 0.1f * vertical;</span><br><span class="line">        //新位置给游戏参数</span><br><span class="line">        rigidbody2D.position = position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //不是系统函数，自定义来更改生命值的</span><br><span class="line">    public void ChangeHealth(int amount) &#123;</span><br><span class="line">        //假设玩家受伤害的时间间隔是2秒</span><br><span class="line">        //不管是什么样的伤害，只要amount小于0，就判断是不是无敌</span><br><span class="line">        if (amount &lt; 0) &#123;</span><br><span class="line">            //判断当前是否处于无敌状态</span><br><span class="line">            if (isInvincible) &#123;</span><br><span class="line">                //无敌不伤血，跳出无敌状态</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //当不是无敌状态时，会执行下面的代码</span><br><span class="line">        //重置无敌状态为真</span><br><span class="line">        isInvincible = true;</span><br><span class="line">        //设置无敌时间</span><br><span class="line">        invincibleTimer = timeInvincible;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //系统函数Clamp，用于限制取值范围的函数</span><br><span class="line">        //0~最大生命值</span><br><span class="line">        currentHealth = Mathf.Clamp(currentHealth + amount, 0, maxHealth);</span><br><span class="line">        //在控制台输出生命信息</span><br><span class="line">        Debug.Log(&quot;当前生命值：&quot; + currentHealth + &quot;/&quot; + maxHealth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2022/04/22/%E8%AE%BE%E7%BD%AE%E6%8E%89%E8%A1%80%E5%8C%BA%E5%9F%9F/">
                设置掉血区域
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2022-04-22</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class damageZone2 : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //每次伤血量</span><br><span class="line">    public int damageNum = -1;</span><br><span class="line"></span><br><span class="line">    //这个触发器是Enter，进入</span><br><span class="line">    //Enter只有在角色进入是时才执行</span><br><span class="line">    //可以将函数名从OnTriggerEnter2D改为OnTriggerStay2D</span><br><span class="line">    //这样，刚体在触发器内的每一帧都会调用此函数</span><br><span class="line">    private void OnTriggerEnter2D(Collider2D other)</span><br><span class="line">    &#123;</span><br><span class="line">        //rubyController获取到这个对象</span><br><span class="line">        RubyController rubyController = other.GetComponent&lt;RubyController&gt;();</span><br><span class="line">        //如果不为空，就进行更改</span><br><span class="line">        if(rubyController!=null) &#123;</span><br><span class="line">            rubyController.ChangeHealth(damageNum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><br></br></p>
<p>为了优化资源，物理系统在刚体停止移动式会停止计算刚体的碰撞；此时刚体进入“睡眠状态”。若是希望在停止时也进行检测，把角色的Rigidbody 2D中的Sleeping Mode选择未Never Sleep(永不睡眠)</p>
<blockquote>
<p>下列是关于Sleeping Mode的信息</p>
</blockquote>
<ul>
<li>Never Sleep  禁用睡眠（应尽可能避免此设置，否则会影响系统资源）</li>
<li>Start Awake  游戏对象最初处于唤醒状态</li>
<li>Start Asleep 游戏对象最处于睡眠状态，但可以被碰撞唤醒</li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2022/04/21/%E5%AE%8C%E5%96%84%E8%A7%A6%E5%8F%91%E5%99%A8%E4%BB%A3%E7%A0%81/">
                完善触发器代码
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2022-04-21</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p>在“世界交互（2）”模块中，我们涉及到了（rubyController）这个游戏对象。如果是一个复杂的游戏，这个rubyController不是我们写的呢，是别人写的游戏对象呢？</p>
<p>因此，使用其他代码里的游戏对象之前，最好先做一下检测，检测它是否获取到，是否为空。</p>
<p><br></br></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (rubyController != null) &#123;</span><br><span class="line">            //吃完（草莓），让（草莓）消失</span><br><span class="line">            //Destory是object里的方法，组类的方法，用来在内存中把当前对象销毁</span><br><span class="line">            //销毁当前游戏对象</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Debug.LogError(&quot;rubyController 游戏组件并未获取到&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></br><br>此外，当（生命值）满的时候，不吃（草莓）来（增加生命值）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (rubyController != null) &#123;</span><br><span class="line">            if (rubyController.currentHealth &lt; rubyController.maxHealth) &#123;</span><br><span class="line">                //吃完（草莓），让（草莓）消失</span><br><span class="line">                //Destory是object里的方法，组类的方法，用来在内存中把当前对象销毁</span><br><span class="line">                //销毁当前游戏对象</span><br><span class="line">                Destroy(gameObject);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            Debug.Log(&quot;当前玩家生命值是满的，不需要加血！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">                Debug.LogError(&quot;rubyController 游戏组件并未获取&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></br><br>在上述代码里（世界交互-2），（ruby）与（草莓），（ruby）的（currentHealth）原是私有的，这里为了调用，将它改为public。</p>
<p>其实这对封装性没有很好的体现，（currentHealth）不应该随便地暴露出来，任意的类在任意的地方，可以任意地更改，这样也容易出现问题。</p>
<p>应该封装起来，用特定的游戏逻辑来进行更改。<br>但是对于（RubyController中的public int currentHealth）还想获取，该怎么办呢？</p>
<blockquote>
<p>其实public int currentHealth 中的currentHealth在c#中应该叫字段。而属性是字段的取值器</p>
</blockquote>
<blockquote>
<p>数据成员的变量，我们称之为字段。对字段进行包装的这种接口，我们称之为属性，通过属性来进行访问</p>
</blockquote>
<p><br></br></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//c#中支持面向对象程序设计中的封装概念，对数据成员的保护</span><br><span class="line">    //数据成员变量，默认一般都应该设置为私有，只能通过对当前类的方法或属性进行访问</span><br><span class="line">    //属性类似于特殊的函数结构，它get是一个关键字</span><br><span class="line">    //get是获取当前属性所绑定的字段的值</span><br><span class="line">    //属性相当于一个盒子，字段是在盒子里的某件东西</span><br><span class="line">    //属性限制了字段的访问规则，比如只能读或写</span><br><span class="line">    //或者读写的时候满足某种需求，才能往外进行操作</span><br><span class="line">    //相当于把它包装起来，这就称为封装</span><br><span class="line">    //属性是公有的，可以通过取值器get、赋值器set设定对应字段的访问规则，满足规则才能进行访问</span><br><span class="line"></span><br><span class="line">    public int health &#123; </span><br><span class="line">        get &#123; return currentHealth; &#125;</span><br><span class="line">        //set &#123; currentHealth = value; &#125;//可赋值</span><br><span class="line">    &#125;</span><br><span class="line">    int currentHealth;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2022/04/21/%E4%B8%96%E7%95%8C%E4%BA%A4%E4%BA%92%EF%BC%882%EF%BC%89/">
                世界交互（2）
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2022-04-21</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="添加生命统计功能"><a href="#添加生命统计功能" class="headerlink" title="添加生命统计功能"></a>添加生命统计功能</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class RubyController : MonoBehaviour&#123;</span><br><span class="line">    //设置最大生命值（生命上限）</span><br><span class="line">    public int maxHealth = 5;</span><br><span class="line">    private int currentHealth;//需要初始值，在start里设置合适</span><br><span class="line"></span><br><span class="line">     private void Start() &#123;</span><br><span class="line">        //获取当前游戏对象的刚体组件</span><br><span class="line">        rigidbody2D = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        //游戏刚开始，玩家满血</span><br><span class="line">        currentHealth = maxHealth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //不是系统函数，自定义来更改生命值的</span><br><span class="line">    void ChangeHealth(int amount) &#123;</span><br><span class="line">        //系统函数Clamp，用于限制取值范围的函数</span><br><span class="line">        //0~最大生命值</span><br><span class="line">        currentHealth = Mathf.Clamp(currentHealth + amount, 0, maxHealth);</span><br><span class="line">        //在控制台输出生命信息</span><br><span class="line">        Debug.Log(&quot;当前生命值：&quot; + currentHealth + &quot;/&quot; + maxHealth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于Mathf.Clamp：是在Mathf这个类里面的，是一个静态类的静态方法（不需要创建对象，直接用类就可以调用；一般我们是用类来创建对象实例，再用对象来调用方法）。</p>
</blockquote>
<blockquote>
<p>在Scripting API可以进行这些功能的查找</p>
</blockquote>
<h1 id="添加触发器"><a href="#添加触发器" class="headerlink" title="添加触发器"></a>添加触发器</h1><p>触发器是一种特殊类型的碰撞体，触发器不会阻止移动，但是物理系统仍会检查角色是否会与触发器碰撞。（只检查碰撞，不挂其他的物理效果；挂了触发器的游戏对象，不会再挂刚体或者其他）</p>
<p>总结：触发器只检测碰撞，不阻止移动；碰撞时，可接受到消息，根据需求添加相关代码<br><br></br></p>
<h2 id="创建可收集生命值游戏对象"><a href="#创建可收集生命值游戏对象" class="headerlink" title="创建可收集生命值游戏对象"></a>创建可收集生命值游戏对象</h2><ul>
<li><p>1.首先，制作（金属箱）</p>
<p> 在Project窗口中，选择<strong>Assets&gt;Art&gt;Sprites&gt;VFX</strong>，并找到<strong>CollectibleHealth</strong>(你想的添加的素材)</p>
<p> 将这个游戏对象导入到<strong>场景中</strong>（拖拽），并调整<strong>PPU值</strong>以设置为适当大小。（在Hierarchy中，把这个对象拖到Perfabs中，我们要开始做预制件了）</p>
<p> 将<strong>Box Collider 2D</strong>组件添加到新游戏对象，调整碰撞体大小，以便更好地适应精灵</p>
</li>
<li><p>2.现在，如果你单击Play，就像（Ruby）会与箱子碰撞一样，她也会与生命值可收集对象碰撞。但是，这不是你需要的效果</p>
</li>
<li><p>3.退出运行模式</p>
</li>
<li><p>4.在Inspector中，找到<strong>Box Collider 2D</strong>组件，启用<strong>Is Trigger复选框</strong>（是否是触发器）</p>
</li>
<li><p>5.在使用触发器的游戏对象上添加脚本组件，在其中添加事件</p>
</li>
</ul>
<blockquote>
<p>void OnTriggerEnter2D（Collider2D other）</p>
</blockquote>
<p>此事件会在每次碰撞时执行，将你需要的逻辑代码写入事件方法中即可</p>
<p>eg</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class HealthCollectible : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    //用来记录碰撞次数</span><br><span class="line">    int collideCount;</span><br><span class="line">    //2D的一个触发器的碰撞事件</span><br><span class="line">    //挂了当前这个脚本组件的游戏对象，每次碰撞会激活这个方法来执行</span><br><span class="line">    //other（collision）是参数名，取什么都行</span><br><span class="line"></span><br><span class="line">    private void OnTriggerEnter2D(Collider2D other) &#123;</span><br><span class="line">        //怎么检测呢，最直接就是在控制台输出一段话</span><br><span class="line">        //这是字符串的一种特殊输出方式</span><br><span class="line">        //不再需要用字符串+连接常量/变量 把它们结合一起了</span><br><span class="line">        //括号内按值输出，括号外原样输出，但是前面必须加$</span><br><span class="line">        collideCount += 1;</span><br><span class="line">        Debug.Log($&quot;和当前物体发生碰撞的对象是：&#123;other&#125;,当前是第&#123;collideCount&#125;次碰撞！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<blockquote>
<p>以下是关于(草莓)与（Ruby）完整的代码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class HealthCollectible : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    //（草莓）加的血量</span><br><span class="line">    //公开出来，想要改的话，直接在Unity里也可以改</span><br><span class="line">    public int amount = 1;</span><br><span class="line"></span><br><span class="line">    //用来记录碰撞次数</span><br><span class="line">    int collideCount;</span><br><span class="line">    //2D的一个触发器的碰撞事件</span><br><span class="line">    //挂了当前这个脚本组件的游戏对象，每次碰撞会激活这个方法来执行</span><br><span class="line">    //other（collision）是参数名，取什么都行</span><br><span class="line">    private void OnTriggerEnter2D(Collider2D other) &#123;</span><br><span class="line">        //怎么检测呢，最直接就是在控制台输出一段话</span><br><span class="line">        //这是字符串的一种特殊输出方式</span><br><span class="line">        //不再需要用字符串+连接常量/变量 把它们结合一起了</span><br><span class="line">        //括号内按值输出，括号外原样输出，但是前面必须加$</span><br><span class="line">        collideCount += 1;</span><br><span class="line">        Debug.Log($&quot;和当前物体发生碰撞的对象是：&#123;other&#125;,当前是第&#123;collideCount&#125;次碰撞！&quot;);</span><br><span class="line"></span><br><span class="line">        //获取（Ruby）游戏对象的脚本组件对象</span><br><span class="line">        //创建一个（RubyController）这个类的对象</span><br><span class="line">        //用GetComponent获取游戏对象的组件</span><br><span class="line">        //什么类型的组件？这里是RubyController的组件</span><br><span class="line">        //GetComponent&lt;&gt;();是c#里一个泛型方法，取指定类型的组件</span><br><span class="line">        //在&lt;&gt;里写什么类型，根据这个类型来找到指定的组件</span><br><span class="line">        RubyController rubyController = other.GetComponent&lt;RubyController&gt;();</span><br><span class="line"></span><br><span class="line">        //这里若是想使用RubyController里的方法，记得改成public</span><br><span class="line">        //把当前（草莓）加的血量传过来</span><br><span class="line">        //更改生命值</span><br><span class="line">        rubyController.ChangeHealth(amount);</span><br><span class="line"></span><br><span class="line">        //吃完（草莓），让（草莓）消失</span><br><span class="line">        //Destory是object里的方法，组类的方法，用来在内存中把当前对象销毁</span><br><span class="line">        //销毁当前游戏对象</span><br><span class="line">        Destroy(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></br></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class RubyController : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    //设置最大生命值（生命上限）</span><br><span class="line">    public int maxHealth = 5;</span><br><span class="line">    private int currentHealth;//需要初始值，在start里设置合适</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //声明刚体对象</span><br><span class="line">    Rigidbody2D rigidbody2D;</span><br><span class="line">    //获取用户输入</span><br><span class="line">    float horizontal;</span><br><span class="line">    float vertical;</span><br><span class="line"></span><br><span class="line">    //将速度暴露出来，使其可调</span><br><span class="line">    public float speed = 0.1f;</span><br><span class="line"></span><br><span class="line">    private void Start() &#123;</span><br><span class="line">        //获取当前游戏对象的刚体组件</span><br><span class="line">        rigidbody2D = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        //游戏刚开始，玩家满血</span><br><span class="line">        currentHealth = maxHealth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Update is called once per frame</span><br><span class="line">    //每帧调用一次Update</span><br><span class="line">    //让游戏对象每帧右移0.1</span><br><span class="line">    void Update() &#123;</span><br><span class="line">        //获取水平输入，按向左，会获得-1.0f；按向右，会获得1.0f</span><br><span class="line">        horizontal = Input.GetAxis(&quot;Horizontal&quot;);</span><br><span class="line">        //获取垂直输入，按向下，会获得-1.0f；按向上，会获得1.0f</span><br><span class="line">        vertical = Input.GetAxis(&quot;Vertical&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //固定时间间隔执行的更新方法</span><br><span class="line">    private void FixedUpdate() &#123;</span><br><span class="line">        //获取当前对象位置</span><br><span class="line">        Vector2 position = transform.position;</span><br><span class="line">        //更改位置</span><br><span class="line">        position.x = position.x + 0.1f * horizontal;</span><br><span class="line">        position.y = position.y + 0.1f * vertical;</span><br><span class="line">        //新位置给游戏参数</span><br><span class="line">        rigidbody2D.position = position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //不是系统函数，自定义来更改生命值的</span><br><span class="line">    public void ChangeHealth(int amount) &#123;</span><br><span class="line">        //系统函数Clamp，用于限制取值范围的函数</span><br><span class="line">        //0~最大生命值</span><br><span class="line">        currentHealth = Mathf.Clamp(currentHealth + amount, 0, maxHealth);</span><br><span class="line">        //在控制台输出生命信息</span><br><span class="line">        Debug.Log(&quot;当前生命值：&quot; + currentHealth + &quot;/&quot; + maxHealth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2022/04/20/%E4%B8%96%E7%95%8C%E4%BA%A4%E4%BA%92/">
                世界交互(1)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2022-04-20</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="什么是物理系统"><a href="#什么是物理系统" class="headerlink" title="什么是物理系统"></a>什么是物理系统</h1><p>若是模拟移动和碰撞，需要使用所有的数学公式来计算对象上的接触和力。但需要编写很多复杂的代码。由于物理定律是相同的，因此可以抽象处代码在所有游戏中共享：这就是物理系统的功能。Unity有一个内置的物理系统，可以计算对象的移动和碰撞。<br><br></br><br>为避免我们对游戏对象中的每个对象进行成本高昂的数学运算，Unity仅对附有Rigidbody 2D组件中的游戏对象执行这些计算</p>
<hr>
<h3 id="最基础的两个组件"><a href="#最基础的两个组件" class="headerlink" title="最基础的两个组件"></a>最基础的两个组件</h3><ul>
<li>Rigidbody 2D</li>
<li>Box Collider 2D (如果碰撞的时候很奇怪，明明没碰到之类就产生效果了，可以点击Edit Collider，调整游戏对象产生效果的框框)</li>
</ul>
<h3 id="关于解决旋转"><a href="#关于解决旋转" class="headerlink" title="关于解决旋转"></a>关于解决旋转</h3><ul>
<li>Rigidbody 2D&gt;Constrains(约束)&gt;Freeze Roation Z<br>旋转时其实是沿着屏幕的z轴旋转的，把这个旋转给关闭了</li>
</ul>
<h3 id="关于解决抖动"><a href="#关于解决抖动" class="headerlink" title="关于解决抖动"></a>关于解决抖动</h3><ul>
<li>移动使用了Transform这样一个变换组件，变化组件并不会考虑碰撞的影响，它只会考虑让它移动的位置。给一个position，就会移动到position。</li>
</ul>
<p>先检测移动，再生效物理引擎<br>每一次移动到碰撞体内，刚体和碰撞体会把它挤出来。进来和出去这种方式，使它不停颤动。结论：Transform这种移动方式，不适合碰撞体。</p>
<p><strong>刚体本身也有一个移动位置的方法</strong></p>
<ul>
<li>前提：</li>
<li>1.因为默认情况下，所有游戏对象都具有一个Transform组件，所以Unity使Transform变量再所有脚本中都可用。但是，必须将Rigidbody组件手动添加到游戏对象，因为Unity并没有将这个变量作为内置变量。</li>
<li>2.物理系统的更新速度与游戏不同。每次游戏计算图像时都会调用Update，问题是调用速度不稳定。</li>
<li>3.为使物理计算保持稳定，需要定期更新（例如，每隔16ms）。Unity有一个名为FixedUpdate的函数，只要你想要直接影响物理组件或对象（例如刚体），就需要使用该函数。<br><br></br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class RubyController : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    //声明刚体对象</span><br><span class="line">    Rigidbody2D rigidbody2D;</span><br><span class="line">    //获取用户输入</span><br><span class="line">    float horizontal;</span><br><span class="line">    float vertical;</span><br><span class="line"></span><br><span class="line">    //将速度暴露出来，使其可调</span><br><span class="line">    public float speed = 0.1f;</span><br><span class="line"></span><br><span class="line">    private void Start() &#123;</span><br><span class="line">        //获取当前游戏对象的刚体组件</span><br><span class="line">        rigidbody2D = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Update is called once per frame</span><br><span class="line">    //每帧调用一次Update</span><br><span class="line">    //让游戏对象每帧右移0.1</span><br><span class="line">    void Update() &#123;</span><br><span class="line">        //获取水平输入，按向左，会获得-1.0f；按向右，会获得1.0f</span><br><span class="line">        horizontal = Input.GetAxis(&quot;Horizontal&quot;);</span><br><span class="line">        //获取垂直输入，按向下，会获得-1.0f；按向上，会获得1.0f</span><br><span class="line">        vertical = Input.GetAxis(&quot;Vertical&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //固定时间间隔执行的更新方法</span><br><span class="line">    private void FixedUpdate() &#123;</span><br><span class="line">        //获取当前对象位置</span><br><span class="line">        Vector2 position = transform.position;</span><br><span class="line">        //更改位置</span><br><span class="line">        position.x = position.x + 0.1f * horizontal;</span><br><span class="line">        position.y = position.y + 0.1f * vertical;</span><br><span class="line">        //新位置给游戏参数</span><br><span class="line">        rigidbody2D.position = position;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
FixedUpdate 0.02s执行一次（也可以在Edit&gt;Project Setting里改），Update不同硬件运行的频率不一样。如果电脑还可以，建议把获取用户输入放到Update里。</li>
</ul>
<hr>
<ul>
<li>在Tilemap设置碰撞体的简单方式是修改Collider Type</li>
<li>如果是Rule Tile需要在Tiling Rules里对每个小的进行修改Collider<br><br></br><h2 id="优化瓦片地图碰撞体"><a href="#优化瓦片地图碰撞体" class="headerlink" title="优化瓦片地图碰撞体"></a>优化瓦片地图碰撞体</h2>正如在Scene视图中看到的，每个瓦片都是一个单独的碰撞体。<br>这会产生两个问题：</li>
<li>物理系统计算量大：如果世界很大，会减慢游戏速度</li>
<li>在瓦片之间的边界上会产生小问题：由于瓦片是两个并排的碰撞体,并且两者之间存在微小间隙，因此有时计算上的微小误差也可能会导致发生碰撞的罕见现象。</li>
</ul>
<p>为了解决以上的问题，Unity提供一个名为Composite Collider 2D的组件。此组件可以获取对象（或者对象的子对象）上的所有碰撞体，并由此创建一个大碰撞体。（虽然有碰撞体的绿框，但是是整体一个大的）</p>
<p>让我们来添加并配置此组件：</p>
<ul>
<li>1.在Hierarchy中，选择Tilemap游戏对象</li>
<li>2.在Inspector中，单击Add Component按钮</li>
<li>3.搜索“Composite Collider 2D”，然后选择此组件</li>
</ul>
<p><em><strong>你会看到自动添加Rigidbody 2D组件，因为符合碰撞体需要Rigidbody 2D才能正常运行。</strong></em></p>
<ul>
<li>4.在Tilemap Collider 2D组件中，启用Used By Composite复选框</li>
<li>5.为了提升游戏性能，在Rigidbody 2D组件中，将Rigidbody Body Type属性设置为Static<br>将此属性设置为Static将阻止你的世界移动，此外还有助于物理系统的优化计算，因为它知道刚体不能移动。</li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2022/04/20/%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%BD%A2%E6%8E%92%E5%BA%8F/">
                场景中的图形排序
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2022-04-20</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="伪透视图"><a href="#伪透视图" class="headerlink" title="伪透视图"></a>伪透视图</h1><p>透视图指的是有深度、距离感的图，一般要在三维中的深度轴来表现场景的深度，而二维游戏中需要通过前后来仿造深度效果。<br><br></br><br>先通过调整瓦片的Order in Layer属性来解决了瓦片地图的排序问题，但并非总希望一个游戏对象在另一个游戏对象之上，比如，在同一个瓦片地图中，玩家角色在一个物体之前（比如一棵树）时，应是玩家遮挡树，而玩家移到树之后，应是树遮挡玩家，这就需要“伪造”透视图。<br><br></br><br>在2D游戏中，场景里的”<strong>前后</strong>“是由y轴决定的，需要让Unity根据游戏对象的y坐标来绘制游戏对象。<br>Y轴y坐标越小，越靠前，应该遮挡y坐标值较大的游戏对象，也就是y坐标较小的游戏对象后绘制，就会位于上层。<br>在游戏中，如果要设置2D伪透视图，需要在项目中更改：</p>
<blockquote>
<p>Edit&gt;Project Setting&gt;Graphics&gt;Camera Settings&gt;Transparency </p>
</blockquote>
<p>Sort Mode&#x3D;Custom Axis&gt;Transparency Sort Axis x&#x3D;0&#x2F;y&#x3D;0&#x2F;z&#x3D;0<br>此设置告诉Unity在y轴上基于精灵的位置来绘制精灵。</p>
<h1 id="关于中心点（pivot）"><a href="#关于中心点（pivot）" class="headerlink" title="关于中心点（pivot）"></a>关于中心点（pivot）</h1><p>更改透视图后，如果感觉很奇怪，可能是未更改中心点，中心点可以在游戏对象里改，也可以在游戏素材里改（游戏对象改话每次都得改，最好在游戏素材里改）<br>修改中心点后，把Sprite Renderer中的Sprite Sort Point由Center改成Pivot</p>
<blockquote>
<p>Sprite Mode&gt;Pivot</p>
</blockquote>
<blockquote>
<p>Sprite Mode&gt;Sprite Editor(移动小蓝点，或输入x y值)</p>
</blockquote>

        </div>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="" href="/page/3/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="" href="/page/5/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This theme was developed by <a target="_blank" rel="noopener" href="https://github.com/klugjo">Jonathan Klughertz</a>. The source code is available on Github. Create Websites. Make Magic.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2022/05/27/3D%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E4%BD%93%E7%A7%AF-%E6%B7%BB%E5%8A%A0%E9%A2%9C%E8%89%B2%E5%88%86%E7%BA%A7-%E6%B3%9B%E5%85%89-10/">3D后期处理体积&amp;添加颜色分级&amp;泛光-10</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2022/05/26/3D%E5%90%8E%E6%9C%9F%E7%89%B9%E6%95%88%E7%AE%80%E4%BB%8B-%E6%B7%BB%E5%8A%A0%E6%8A%97%E9%94%AF%E9%BD%BF-9/">3D后期特效简介&amp;添加抗锯齿-9</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2022/05/25/3D%E4%BD%BF%E7%94%A8Cinemachine%E6%9E%84%E5%BB%BA3D%E6%91%84%E5%83%8F%E6%9C%BA%E8%B7%9F%E9%9A%8F-8/">3D使用Cinemachine构建3D摄像机跟随-</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2022/05/24/3DNavMesh%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F-7/">3DNavMesh导航系统-7</a>
            </li>
            
        </ul>
    </div>



            
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://github.com/klugjo/hexo-theme-alpha-dust">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://twitter.com/?lang=en">
                            <span class="footer-icon-container">
                                <i class="fa fa-twitter"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://www.facebook.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-facebook"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://www.instagram.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-instagram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://dribbble.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-dribbble"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://telegram.org/">
                            <span class="footer-icon-container">
                                <i class="fa fa-telegram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://www.behance.net/">
                            <span class="footer-icon-container">
                                <i class="fa fa-behance"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://500px.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-500px"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:test@example.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a target="_blank" rel="noopener" href="http://www.codeblocq.com/">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->

<script src="/js/main.js"></script>


<!-- Disqus Comments -->



</body>

</html>